=======================
  3.상수와 형 변환
=======================

- 정수형 상수와 실수형 상수의 표현 자료형
  1. 정수형 상수 int형으로 표현
  2. 실수형 상수 double형으로 표현


- 형 변환> 데이터타입 변환

   1. 자동 형 변환(묵시적 형 변환)

   2. 강제 형 변환(명시적 형 변환)


---------------------------------------------------------------------------------------
■ 자동 형 변환(Implict Conversion) 규칙

┌──────────────────────────┐
│   1        2         4       8       4        8    │
│  byte -> short ->   int -> long -> float -> double │
│          char  -> ┘                               │
│           2                                        │
└──────────────────────────┘

  정수 byte, short, int, long // 큰 그릇에 있는 것은 작은 그릇에 옮기지 못한다.
 
  byte 5 + int 10 -> int 5 + int 10
  short 10 + byte 5 -> short 10 + short 10
  // 자동형변환규칙의 순서로 간다. 왼 -> 오



  실수 float, double //
   
  long -> float -> 될까? 의문 -> 가능  
  - float 표현범위가 long보다 훨씬 컸었다. 
  - float이 표현할 수 있는 건 long이 표현 못함
  
  int 20 + float 20.0 -> float 20.0 + float 20.0



  문자 char -> 문자 저장이 아니라 아스키코드 값이 저장되어 있음
               -> 그래서 자동 형 변환 규칙에 포함되어 있는 것이다.
  'A' + 10 -> 65 + 10 -> 75
  // 자동 형 변환 규칙 그림에서 short 밑에 있는 이유는 둘 다 2바이트이기 때문임.


---------------------------------------------------------------------------------------
■ 접미사 이야기

  int num = 10000000000; // 백억  
  long num = 10000000000; // 백억
  // 둘 다 오류남
  // 오른쪽의 '백억'이라는 숫자가 문제인 것.


<정수> - 접미사 l, L : 이번만큼은 long 형에다가 담아줘
  int num = 10000000000l;   
	↓
  long num = 10000000000l;
  // 자동 형 변환 규칙으로 long에서 int x


<실수> - 접미사  F,f는 float형 상수 표현을 의미한다.
  float pi = 3.14;
  // 왼쪽을 가리고 오른쪽만 보면 8바이트의 double에다 잡아준다.
  // 그리고 왼쪽을 본다. float = double
  // 그리고 대입을 하면  자동 형 변환규칙에 맞지 않아 에러가 난다.
          ↓
  float pi = 3.14f;
  double num2 = 3.5f + 12; //12가 12f로 자동 형 변환


---------------------------------------------------------------------------------------
■ 명시적 형 변환
- 명시적 형 변환을 하는 이유
  1. 자동 형 변환 규칙에 위배되지만 변환해야 할 때 case 1
     long a = 10;
     byte b = a; //자동 형 변환 규칙에 위배된다.
     // 하지만 a에 있는 10은 바이트 타입으로 표현하기 충분하다.
     -> byte b = (byte)a;


  2. 자동 형 변환 발생지점을 표시하기 위해서 case 2
     int num3 = 100;
     long num4 = (long)num3;  //(long)이 없어도 에러없이 돌아가는 코드지만
     //의도적으로 표시해주는 것이다. 의미 표시를 협업하는 다른 사람에게 전달해주는 역할
     //없어도 되지만 쓰는 경우가 존재한다.



---------------------------------------------------------------------------------------












=======================
  4.연산자(Operator)
=======================

---------------------------------------------------------------------------------------
이항 연산자

■ ( ), 괄호는 우선순위 0순위


■ 산술 연산자
 +(덧셈) - 두 피연산자 중 하나라도 문자가 있으면 문자열 결합 연산자로 사용된다.
 /(나눗셈) - 두 피연산자 중에 하나라도 실수가 있으면 실수 기반 연산.
 % - 나머지 연산자, 나머지를 구한다.


■ 복합대입연산자
 a += b : 'a를 b만큼 증가시켜라' 라고 '+=' 를 그냥 직관적으로 하나로 보자.
 a가 주체, 대상
 ( -= , *= , /= , %= )

  a + b , a * b 는 a와 b는 바뀌지 않지만
  복합대입연산자를 실행하면 a += b 하면 a의 값은 바뀐다.     



■ 관계연산자
  > , < , >= , <= , ==(같다) , !=(다르다)

  - 문법적으로 대입연산자가 먼저 만들어졌다. = , ==
  - 자바에서 !(느낌표)는 부정의 의미. !=

  - 모든 관계연산자는 true 또는 false
      a+b -> 연산결과가 어떤 특정한 값일 것이다.
      a<b -> 관계연산의 연산 결과는 항상 true 또는 false로 나온다.




 자바라는 문법 안에서는 ;(세미콜론) : 문장을 종료시키는 종결자
 환경변수 설정에서는 구분자로 사용되었다.


■ 논리연산자

 - && : a && b , a와 b 모두 true이면 결과는 true, (논리 AND) 
 - || : a || b , a와 b 둘 중 하나라도 true이면 연산결과는 true (논리 OR)
 - !  : !a, !b , 논리부정, (논리 NOT)

 - SCE(SHORT CIRCUIT EVOLUTION)
   구태여 필요없는 연산까지 실행하지 않는다.
   false && 식 -> false && true 까지 안해봐도 이미 false가 나왔으니.
   논리 AND상황에서 이미 FALSE가 나왔으면 뒤에 것은 연산하지 않는다.   
	
   int num1=0, num2 =0;
   boolean result;
   result = (num1 += 10) < 0 && (num2 += 10) > 0;
   넘어갔기 때문에 앞에 식 num1 = 10이고 num2 = 0




---------------------------------------------------------------------------------------
단항 연산자

■ 부호 연산자로서의 + 와 -
  - '-'는 부호를 바꾸는 역할을 한다.
     '-'가 음수로 만드는 것이라고 생각하는 것은 틀린 말이다.
  - +는 특별히 하는 일이 없다.

■ 증감 연산자

  ++ : 증가연산자
  -- : 감소연산자

  - 증감연산은 1만큼 증가시키는 것 고정이다.
  - 먼저 증가시키고 사용하는지  아니면  먼저 사용하고 다음 처리에서 시키느냐 차이
    a++, a--  :  (postfix),  a를 1만큼 증가, 감소시켜라 (다음 처리에서)
    ++a, --a  :  (prefix), a를 1만큼 증가, 감소시켜라 (지금 당장!)


※ 메소드 영역 안에서만큼은 코드가 순차적으로 실행된다.


  
---------------------------------------------------------------------------------------
비트와 관련있는 연산자들 (비트 단위 연산자 or 비트 연산자)


1. 경력자들은 비트연산자로 해결할 수 있는 문제가 더 많다.
비트단위연산자는 경력이나 실력에 따라서 연산자의 활용범위가 크거나 넓고 또는 작거나 좁다.
2. 초급개발자들 눈에는 비트 연산자로 해결해야 할 것들이 눈에 잘 보이지 않을 것이다.
   쓸 수 있는 상황이면 최대한 사용하는 것이 좋다. -> 퍼포먼스 향상
   왜? 연산 처리하는 속도가 매우 빠르기 때문이다. 
       비트 시프트 연산은 타의 추종 불허할만큼 빠르다.

피연산자를 비트 단위로 바꿔서 연산을 수행한다.
5+1 = 6 이 아니라 비트열 기반으로 00000101 + 00000001





■ 비트 연산자
 & : 비트 AND,   15 & 10 -> 00001111(15) & 00001010(10) -> 00001010(10) 
 | : 비트 OR,    15 | 10 -> 00001111(15) | 00001010(10) -> 00001111(15) 
 ~ : 비트 NOT,  ~15, ~10 -> 00001111 → 11110000 , 00001010 → 11110101(5)
 ^ : 비트 XOR(같으면 0, 다르면1), 15 ^ 10 -> 00001111(15) | 00001010(10) -> 00000101(5)

     15 - 10 -> 5
     15 ^ 10 -> 5 : 이게 더 빠르다.




■ 비트 쉬프트(SHIFT) 연산자 -> 비트 연산자 중에서도 가장빠르다.
비트열을 이동시키는 연산
부등호로 보지말고 화살표로 봐본다.
장점 - 메모리 덜 사용, 리소스 소모도 적다.

 << : 왼편으로 이동시켜라, << 와 >>> 이게 상대되는 개념
      10 << 2 -------> 00001010(10) << 2 ------> 00101000(40)

 >> : 
       양수일 때 빈칸은 0으로 채우고 음수일 때는 1로 채운다.
       음수 10110001 -> 11101100
       양수 00001010 -> 00000010


 >>> : 10 >>> 3 -------> 00001010(10) >>> 3 ------> 00000001(1)

       >> 와 차이는 >>는 10110001 -> 11101100 이고 >>>는 10001100 -> 00100011

※ <<< 이건 없음.


---------------------------------------------------------------------------------------


























